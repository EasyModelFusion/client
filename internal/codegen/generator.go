package codegen

import (
	"errors"
	"strings"
)

type PythonCodeGenerator struct {
	sb               *strings.Builder
	indentLevel      int  // current indentation level
	indentFourSpaces bool // if true, use 4 spaces for indentation, otherwise use 8 spaces
	currentLine      int  // current line number
	currentColumn    int  // current column number
}

// NewPythonCodeGenerator creates a new PythonCodeGenerator
func NewPythonCodeGenerator(indentFourSpaces bool) *PythonCodeGenerator {
	return &PythonCodeGenerator{sb: &strings.Builder{}, indentLevel: 0, indentFourSpaces: indentFourSpaces}
}

// Up increases the indentation level
func (cg *PythonCodeGenerator) Up() {
	cg.indentLevel++
}

// Down decreases the indentation level
func (cg *PythonCodeGenerator) Down() {
	cg.indentLevel--
	if cg.indentLevel < 0 {
		cg.indentLevel = 0
	}
}

// appendIndented appends a line to the generated code with the correct indentation
func (cg *PythonCodeGenerator) appendIndented(line string) {
	var tab = "    "
	if !cg.indentFourSpaces {
		tab = strings.Repeat(tab, 2)
	}
	indentation := strings.Repeat(tab, cg.indentLevel)
	cg.sb.WriteString(indentation + line)
	if strings.HasSuffix(line, "\n") {
		cg.currentLine++
		cg.currentColumn = 0
		return
	}
	cg.currentColumn += len(indentation) + len(line)
}

// append appends a line to the generated code
func (cg *PythonCodeGenerator) append(line string) {
	cg.sb.WriteString(line)
	if strings.HasSuffix(line, "\n") {
		cg.currentLine++
		cg.currentColumn = 0
		return
	}
	cg.currentColumn += len(line)
}

// newLine adds a new line to the generated code
func (cg *PythonCodeGenerator) newLine() {
	cg.currentLine++
	cg.currentColumn = 0
	cg.sb.WriteString("\n")
}

// VisitFile visits a File node
func (cg *PythonCodeGenerator) VisitFile(file *File) error {
	cg.append("# Code generated by EMF\n")
	cg.append("# DO NOT EDIT!\n")
	cg.newLine()

	for _, importStmt := range file.Imports {
		err := importStmt.Accept(cg)
		if err != nil {
			return err
		}
	}
	for _, class := range file.Classes {
		err := class.Accept(cg)
		if err != nil {
			return err
		}
	}
	for _, function := range file.Functions {
		err := function.Accept(cg)
		if err != nil {
			return err
		}
	}
	return nil
}

// VisitFunction visits a Function node
func (cg *PythonCodeGenerator) VisitFunction(function *Function) error {
	if function.Name == "" {
		return errors.New("function name cannot be empty")
	}

	cg.appendIndented("def " + function.Name + "(")
	for i, param := range function.Params {
		if i > 0 && i < len(function.Params) {
			cg.append(", ")
		}
		err := param.Accept(cg)
		if err != nil {
			return err
		}
	}

	if function.ReturnType != "" {
		cg.append(") -> " + function.ReturnType + ":\n")
	} else {
		cg.append("):\n")
	}

	cg.appendIndented("def " + function.Name + "(")
	for i, param := range function.Params {
		if i > 0 {
			cg.sb.WriteString(", ")
		}
		cg.sb.WriteString(param.Name + ": " + param.Type)
	}
	cg.appendIndented("):\n")

	return nil
}

// VisitClass visits a Class node
func (cg *PythonCodeGenerator) VisitClass(class *Class) error {
	return nil
}

// VisitField visits a Field node
func (cg *PythonCodeGenerator) VisitField(field *Field) error {
	return nil
}

// VisitParameter visits a Parameter node
func (cg *PythonCodeGenerator) VisitParameter(parameter *Parameter) error {
	if parameter.Name == "" {
		return errors.New("parameter name cannot be empty")
	}
	if parameter.Type == "" {
		cg.append(parameter.Name)
		return nil
	}

	cg.append(parameter.Name + ": " + parameter.Type)
	return nil
}

// VisitImport visits an Import node
func (cg *PythonCodeGenerator) VisitImport(importStmt *Import) error {
	return nil
}
